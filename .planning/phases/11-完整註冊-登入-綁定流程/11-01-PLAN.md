---
phase: 11-完整註冊-登入-綁定流程
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/handlers/class-login-handler.php
autonomous: true

must_haves:
  truths:
    - "已登入用戶可在綁定確認頁面點擊確認後,LINE 帳號綁定到當前 WordPress 帳號"
    - "綁定時若 LINE UID 已綁定其他用戶則顯示錯誤"
    - "綁定時若當前用戶已綁定其他 LINE 則顯示錯誤"
    - "綁定成功後用戶被導回原始頁面"
  artifacts:
    - path: "includes/handlers/class-login-handler.php"
      provides: "handle_link_submission() 方法"
      contains: "function handle_link_submission"
    - path: "includes/handlers/class-login-handler.php"
      provides: "handle_login_init() 中的 buygo_line_link action 檢查"
      contains: "buygo_line_link"
  key_links:
    - from: "handle_login_init()"
      to: "handle_link_submission()"
      via: "POST action === buygo_line_link"
      pattern: "buygo_line_link.*handle_link_submission"
    - from: "handle_link_submission()"
      to: "LineUserService::linkUser()"
      via: "綁定執行"
      pattern: "linkUser.*false"
---

<objective>
實作已登入用戶綁定 LINE 帳號的表單提交處理（FLOW-03）

Purpose: 完成 Phase 11 的核心功能 - 讓已登入 WordPress 的用戶可以從綁定確認頁面完成 LINE 帳號綁定
Output: Login_Handler 中新增 handle_link_submission() 方法,處理綁定表單提交
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-完整註冊-登入-綁定流程/11-RESEARCH.md
@includes/handlers/class-login-handler.php
@includes/services/class-line-user-service.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 新增 handle_link_submission() 方法</name>
  <files>includes/handlers/class-login-handler.php</files>
  <action>
在 Login_Handler 類別中新增 handle_link_submission() 方法:

1. **在 handle_login_init() 中新增 link action 檢查**（約第 93 行後）:
```php
// 檢查是否為綁定表單提交
if ( isset( $_POST['action'] ) && $_POST['action'] === 'buygo_line_link' ) {
    $this->handle_link_submission();
    return;
}
```

2. **新增 handle_link_submission() 方法**（在 handle_auto_link() 之後）:

方法內容應包含:
- Nonce 驗證（buygo_line_link_nonce / buygo_line_link_action）
- State 驗證（從 Transient 讀取 profile）
- 用戶 ID 一致性驗證（state_data['user_id'] === get_current_user_id()）
- LINE UID 是否已綁定其他用戶檢查（LineUserService::getUserByLineUid）
- 當前用戶是否已綁定其他 LINE 檢查（LineUserService::getLineUidByUserId）
- 執行綁定（LineUserService::linkUser, is_registration = false）
- 儲存 LINE 頭像到 user_meta
- 清除 Transient
- 觸發 buygo_line_after_link hook
- 設定成功通知（Transient）
- 導向到 redirect_url

3. **錯誤處理策略（使用者友善版本）**:

使用 transient + redirect 模式取代 wp_die()，提供更好的使用者體驗:

```php
// 錯誤處理 helper method
private function redirect_with_error( string $error_code, string $message, string $redirect_url ): void {
    set_transient(
        'buygo_line_link_error_' . get_current_user_id(),
        array(
            'code'    => $error_code,
            'message' => $message,
            'time'    => time(),
        ),
        60 // 1 分鐘過期
    );
    wp_safe_redirect( add_query_arg( 'line_link_error', $error_code, $redirect_url ) );
    exit;
}
```

錯誤處理邏輯:
- **Nonce 驗證失敗**: 不清除 Transient，redirect_with_error('nonce_failed', '安全驗證失敗，請重新操作', $redirect_url)
- **用戶 ID 不一致**: 清除 Transient，redirect_with_error('user_mismatch', '身份驗證失敗，請重新登入', wp_login_url())
- **LINE UID 已綁定其他用戶**: 清除 Transient，redirect_with_error('line_already_linked', '此 LINE 帳號已綁定其他用戶，若需解除綁定請聯繫管理員', $redirect_url)
- **當前用戶已綁定其他 LINE**: 清除 Transient，redirect_with_error('user_already_linked', '您的帳號已綁定其他 LINE 帳號，請先解除綁定', $redirect_url)
- **綁定失敗（資料庫錯誤）**: 清除 Transient，redirect_with_error('link_failed', '綁定失敗，請稍後再試', $redirect_url)

4. **參考 handle_register_submission() 的模式**但調整為綁定邏輯。

**注意：不要建立新用戶，只執行 linkUser() 綁定。**
  </action>
  <verify>
grep -n "handle_link_submission" includes/handlers/class-login-handler.php | head -5
grep -n "buygo_line_link" includes/handlers/class-login-handler.php | head -5
grep -n "redirect_with_error" includes/handlers/class-login-handler.php | head -3
  </verify>
  <done>
- handle_link_submission() 方法已存在於 Login_Handler 中
- handle_login_init() 中有 buygo_line_link action 檢查
- 方法包含所有必要的驗證和綁定邏輯
- 錯誤處理使用 redirect_with_error() 提供使用者友善訊息
  </done>
</task>

<task type="auto">
  <name>Task 2: 修改 handle_callback() 補充綁定流程判斷</name>
  <files>includes/handlers/class-login-handler.php</files>
  <action>
修改 handle_callback() 方法,在查詢 LINE UID 之後加入綁定流程判斷。

**關鍵：綁定流程判斷必須在 `if ($user_id)` 登入判斷之前執行。**

1. **找到現有代碼位置**（目前約第 271-274 行）:
```php
// 3. 查詢是否已綁定用戶
$user_id = LineUserService::getUserByLineUid( $line_uid );

if ( $user_id ) {
    // 已綁定用戶，執行登入
    ...
```

2. **在 `$user_id = LineUserService::getUserByLineUid()` 之後，`if ($user_id)` 之前，插入綁定流程檢查**:

修改後的結構應為:
```php
// 3. 查詢是否已綁定用戶
$user_id = LineUserService::getUserByLineUid( $line_uid );

// 4. 檢查是否為綁定流程（state_data 包含有效 user_id）
// 重要：此判斷必須在 if ($user_id) 登入判斷之前執行
$link_user_id = $state_data['user_id'] ?? 0;

if ( $link_user_id > 0 ) {
    // 這是綁定流程

    // 4a. 若 LINE UID 已綁定其他用戶,拒絕
    if ( $user_id && $user_id !== $link_user_id ) {
        Logger::get_instance()->log(
            'error',
            array(
                'message'       => 'Link flow: LINE UID already linked to another user',
                'link_user_id'  => $link_user_id,
                'existing_user' => $user_id,
                'line_uid'      => $line_uid,
            )
        );
        wp_die( '此 LINE 帳號已綁定其他用戶', 'Error', array( 'response' => 400 ) );
    }

    // 4b. 若 LINE UID 已綁定同一用戶,直接登入
    if ( $user_id === $link_user_id ) {
        Logger::get_instance()->log(
            'info',
            array(
                'message' => 'Link flow: Already linked, logging in',
                'user_id' => $user_id,
            )
        );
        $this->perform_login( $user_id, $state_data );
        return;
    }

    // 4c. 儲存 profile 並拋出 FLOW_LINK 例外
    $profile_key = self::PROFILE_TRANSIENT_PREFIX . $state;
    set_transient(
        $profile_key,
        array(
            'profile'    => $profile,
            'state_data' => $state_data,
            'state'      => $state,
            'timestamp'  => time(),
        ),
        self::PROFILE_TRANSIENT_EXPIRY
    );

    throw new NSLContinuePageRenderException(
        NSLContinuePageRenderException::FLOW_LINK,
        array(
            'profile'    => $profile,
            'state_data' => $state_data,
            'state'      => $state,
            'user_id'    => $link_user_id,
        )
    );
    // 注意：throw 後不會繼續執行，所以不需要 return
}

// 5. 非綁定流程：原有的登入/註冊邏輯
if ( $user_id ) {
    // 已綁定用戶，執行登入
    $this->perform_login( $user_id, $state_data );
} else {
    // 未綁定用戶，需要註冊流程
    ...
}
```

3. **為什麼順序很重要**:
- 如果 `if ($user_id)` 在綁定判斷之前執行，已登入用戶發起綁定時，若其 LINE UID 恰好已綁定自己（或其他情況），會進入登入流程而非綁定確認流程
- 綁定流程判斷必須優先，因為它有明確的 `link_user_id > 0` 條件標識

4. **確保原有邏輯不變**:
- 非綁定流程（link_user_id 為 0）會跳過新增的判斷區塊
- 原有的 `if ($user_id)` 登入和 `else` 註冊邏輯保持不變
  </action>
  <verify>
grep -n "link_user_id" includes/handlers/class-login-handler.php | head -5
grep -n "FLOW_LINK" includes/handlers/class-login-handler.php | head -5
# 確認順序正確：link_user_id 判斷在 "if ( \$user_id )" 之前
grep -n -A2 "link_user_id > 0" includes/handlers/class-login-handler.php | head -10
  </verify>
  <done>
- handle_callback() 包含 link_user_id 變數和綁定流程判斷
- 綁定流程判斷位於 `if ($user_id)` 登入判斷之前
- 綁定流程正確拋出 FLOW_LINK 例外
- LINE UID 衝突時正確拒絕
- 非綁定流程時跳過新增邏輯，保持原有行為
  </done>
</task>

</tasks>

<verification>
1. grep 確認 handle_link_submission() 存在
2. grep 確認 handle_login_init() 有 buygo_line_link action 檢查
3. grep 確認 handle_callback() 有 link_user_id 綁定流程判斷
4. grep 確認 link_user_id 判斷在 if ($user_id) 之前
5. PHP 語法檢查: php -l includes/handlers/class-login-handler.php
</verification>

<success_criteria>
- [ ] handle_link_submission() 方法已新增且包含完整驗證邏輯
- [ ] 錯誤處理使用 redirect_with_error() 而非 wp_die()（提供使用者友善訊息）
- [ ] handle_login_init() 有 buygo_line_link action 檢查
- [ ] handle_callback() 有 link_user_id 綁定流程判斷
- [ ] link_user_id 判斷位於 if ($user_id) 登入判斷之前（順序正確）
- [ ] PHP 語法正確（php -l 無錯誤）
- [ ] 所有 grep 驗證通過
</success_criteria>

<output>
After completion, create `.planning/phases/11-完整註冊-登入-綁定流程/11-01-SUMMARY.md`
</output>
