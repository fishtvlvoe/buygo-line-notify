---
phase: 01-基礎設施與設定
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/services/class-settings-service.php
autonomous: true

must_haves:
  truths:
    - "敏感設定（Token、Secret）以加密方式儲存在 WordPress options"
    - "可透過 SettingsService::get() 自動解密讀取設定"
    - "向後相容：能讀取舊外掛（buygo_core_settings）的加密資料"
    - "加密金鑰可透過 wp-config.php 定義（BUYGO_ENCRYPTION_KEY）"
  artifacts:
    - path: "includes/services/class-settings-service.php"
      provides: "設定加解密與向後相容讀取"
      exports: ["get", "set", "encrypt", "decrypt"]
      min_lines: 100
  key_links:
    - from: "includes/services/class-settings-service.php"
      to: "WordPress Options API"
      via: "get_option and update_option"
      pattern: "(get|update)_option.*buygo_line"
    - from: "includes/services/class-settings-service.php"
      to: "OpenSSL"
      via: "openssl_encrypt and openssl_decrypt"
      pattern: "openssl_(en|de)crypt"
---

<objective>
實作設定管理服務，提供加密儲存和向後相容讀取功能。

Purpose: 安全儲存 LINE API 金鑰，同時維持與舊外掛（buygo-plus-one-dev）的向後相容性。
Output: SettingsService class（加解密、讀寫、向後相容）。
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-基礎設施與設定/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# 現有程式碼參考
@includes/class-plugin.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 實作 SettingsService 加解密與向後相容</name>
  <files>includes/services/class-settings-service.php</files>
  <action>
建立 SettingsService，實作 OpenSSL AES-128-ECB 加密和向後相容讀取。

**實作要求（參考 RESEARCH.md Pattern 2）：**
```php
namespace BuygoLineNotify\Services;

class SettingsService {

    /**
     * 需要加密的欄位列表
     */
    private static array $encrypted_fields = [
        'channel_access_token',
        'channel_secret',
        'login_channel_id',
        'login_channel_secret',
    ];

    /**
     * 取得加密金鑰
     * 優先使用 wp-config.php 定義的 BUYGO_ENCRYPTION_KEY
     */
    private static function get_encryption_key(): string {
        return defined('BUYGO_ENCRYPTION_KEY')
            ? BUYGO_ENCRYPTION_KEY
            : 'buygo-secret-key-default';
    }

    /**
     * 加密演算法（與舊外掛相同，確保向後相容）
     */
    private static function cipher(): string {
        return 'AES-128-ECB';
    }

    /**
     * 加密資料
     */
    private static function encrypt(string $data): string {
        if (empty($data)) {
            return $data;
        }

        $encrypted = openssl_encrypt($data, self::cipher(), self::get_encryption_key());
        return $encrypted !== false ? $encrypted : $data;
    }

    /**
     * 解密資料
     */
    private static function decrypt(string $data): string {
        if (empty($data)) {
            return $data;
        }

        $decrypted = openssl_decrypt($data, self::cipher(), self::get_encryption_key());

        // 解密失敗時返回原值（避免 Pitfall 2）
        return $decrypted !== false ? $decrypted : $data;
    }

    /**
     * 檢查欄位是否需要加密
     */
    private static function is_encrypted_field(string $key): bool {
        return in_array($key, self::$encrypted_fields, true);
    }

    /**
     * 讀取設定（含向後相容）
     * 優先順序：buygo_line_{key} > buygo_core_settings[key] > default
     */
    public static function get(string $key, $default = null) {
        // 優先從新外掛 option 讀取
        $option_key = "buygo_line_{$key}";
        $value = get_option($option_key, '');

        if (!empty($value)) {
            // 如果是加密欄位，解密
            if (self::is_encrypted_field($key)) {
                return self::decrypt($value);
            }
            return $value;
        }

        // 向後相容：從舊外掛讀取
        $core_settings = get_option('buygo_core_settings', []);
        if (isset($core_settings[$key]) && !empty($core_settings[$key])) {
            $value = $core_settings[$key];

            // 舊資料也可能加密
            if (self::is_encrypted_field($key)) {
                return self::decrypt($value);
            }
            return $value;
        }

        return $default;
    }

    /**
     * 儲存設定（自動加密敏感欄位）
     */
    public static function set(string $key, $value): bool {
        if (self::is_encrypted_field($key) && !empty($value)) {
            $value = self::encrypt($value);
        }

        $option_key = "buygo_line_{$key}";
        return update_option($option_key, $value);
    }

    /**
     * 刪除設定
     */
    public static function delete(string $key): bool {
        $option_key = "buygo_line_{$key}";
        return delete_option($option_key);
    }

    /**
     * 取得所有設定（用於設定頁面顯示）
     */
    public static function get_all(): array {
        $keys = [
            'channel_access_token',
            'channel_secret',
            'login_channel_id',
            'login_channel_secret',
            'liff_id',
            'liff_endpoint_url',
        ];

        $settings = [];
        foreach ($keys as $key) {
            $settings[$key] = self::get($key, '');
        }

        return $settings;
    }
}
```

**重要說明：**
- 使用 AES-128-ECB（與舊外掛相同），而非 AES-256-GCM（避免向後相容問題，參考 RESEARCH.md Open Question 1）
- 解密失敗時返回原值，不拋出錯誤（避免 Pitfall 2）
- 優先讀取 buygo_line_{key}，失敗時讀取 buygo_core_settings（向後相容）

已存在的 SettingsService 需要更新或覆寫。檢查現有檔案：
```bash
cat includes/services/class-settings-service.php
```

如果現有檔案簡單，直接覆寫。如果已有複雜邏輯，保留既有方法並整合上述功能。
  </action>
  <verify>
建立測試腳本驗證加解密和向後相容：
```php
// 測試加密和儲存
\BuygoLineNotify\Services\SettingsService::set('channel_access_token', 'test-token-123');
\BuygoLineNotify\Services\SettingsService::set('liff_id', 'liff-123'); // 非加密欄位

// 測試讀取（應該自動解密）
$token = \BuygoLineNotify\Services\SettingsService::get('channel_access_token');
echo "Token: {$token}\n"; // should be 'test-token-123'

// 檢查資料庫中的值是否加密
global $wpdb;
$encrypted = $wpdb->get_var("SELECT option_value FROM {$wpdb->options} WHERE option_name = 'buygo_line_channel_access_token'");
echo "Encrypted in DB: {$encrypted}\n"; // should NOT be 'test-token-123'

// 測試向後相容（模擬舊外掛的設定）
update_option('buygo_core_settings', [
    'channel_access_token' => \BuygoLineNotify\Services\SettingsService::encrypt('old-token-456'),
    'liff_id' => 'old-liff-456'
]);

// 刪除新外掛設定，強制讀取舊設定
delete_option('buygo_line_channel_access_token');

$old_token = \BuygoLineNotify\Services\SettingsService::get('channel_access_token');
echo "Old token: {$old_token}\n"; // should be 'old-token-456'
```

執行：
```bash
cd /Users/fishtv/Local\ Sites/buygo/app/public
wp eval-file test-settings.php
```
  </verify>
  <done>
- SettingsService 實作完成，包含加解密方法
- get() 方法支援向後相容（優先新設定，備用舊設定）
- set() 方法自動加密敏感欄位
- 加密使用 AES-128-ECB（與舊外掛相同）
- 測試腳本驗證通過（加密儲存、解密讀取、向後相容）
  </done>
</task>

</tasks>

<verification>
1. 執行 Task 1 的測試腳本，確認加解密正確
2. 檢查 wp_options 中的 buygo_line_channel_access_token 值，應該是加密後的字串
3. 測試向後相容：建立 buygo_core_settings option，確認能讀取
4. 測試解密失敗不會中斷（使用錯誤的 BUYGO_ENCRYPTION_KEY）
</verification>

<success_criteria>
- [ ] SettingsService::get() 可正確讀取並解密設定
- [ ] SettingsService::set() 自動加密敏感欄位
- [ ] 向後相容：能讀取 buygo_core_settings 中的設定
- [ ] 加密金鑰可透過 BUYGO_ENCRYPTION_KEY 常數定義
- [ ] 解密失敗時返回原值，不拋出錯誤
</success_criteria>

<output>
After completion, create `.planning/phases/01-基礎設施與設定/01-02-SUMMARY.md`
</output>
