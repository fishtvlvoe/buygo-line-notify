---
phase: 01-後端設定架構
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/schemas/class-settings-schema.php
  - includes/services/class-settings-service.php
  - includes/class-plugin.php
autonomous: true

must_haves:
  truths:
    - "所有設定群組（messaging_api, login, button, email, integrations, sync, liff）都有明確的 Schema 定義"
    - "每個設定欄位都有預設值、驗證規則、清理函式"
    - "SettingsService 可讀取/寫入群組化設定"
    - "敏感欄位（token, secret）自動加密儲存"
    - "向後相容現有的單一 key 設定讀取"
  artifacts:
    - path: "includes/schemas/class-settings-schema.php"
      provides: "設定 Schema 定義和驗證邏輯"
      exports: ["Settings_Schema"]
      min_lines: 150
    - path: "includes/services/class-settings-service.php"
      provides: "擴展的設定服務（群組化操作）"
      exports: ["SettingsService"]
      contains: "get_group"
  key_links:
    - from: "includes/services/class-settings-service.php"
      to: "includes/schemas/class-settings-schema.php"
      via: "Settings_Schema::get_schema() 取得驗證規則"
      pattern: "Settings_Schema::get_schema"
    - from: "includes/services/class-settings-service.php"
      to: "WordPress Options API"
      via: "get_option/update_option 儲存群組設定"
      pattern: "(get_option|update_option)\\("
---

<objective>
建立統一的設定 Schema 定義和擴展 SettingsService 支援群組化設定操作。

Purpose: 為所有 LINE 整合設定建立標準化的資料結構和驗證規則，讓後續的 REST API 和前端介面有穩固的資料基礎。

Output:
- Settings_Schema 類別：定義所有設定群組的結構、驗證規則、預設值
- 擴展的 SettingsService：支援 get_group/set_group 群組化操作
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-後端設定架構/01-RESEARCH.md

# 現有程式碼參考
@includes/services/class-settings-service.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 建立 Settings_Schema 類別</name>
  <files>includes/schemas/class-settings-schema.php</files>
  <action>
建立 `includes/schemas/` 目錄和 `class-settings-schema.php` 檔案。

Schema 類別需包含：

1. **GROUPS 常數**：定義所有設定群組名稱
   - messaging_api, login, button, email, integrations, sync, liff

2. **get_schema() 方法**：回傳完整的 Schema 定義
   根據 01-RESEARCH.md 的資料結構：

   ```php
   'messaging_api' => [
       'channel_access_token' => ['type' => 'string', 'encrypted' => true, 'default' => ''],
       'channel_secret' => ['type' => 'string', 'encrypted' => true, 'default' => ''],
   ],
   'login' => [
       'channel_id' => ['type' => 'string', 'encrypted' => true, 'default' => ''],
       'channel_secret' => ['type' => 'string', 'encrypted' => true, 'default' => ''],
       'default_redirect_url' => ['type' => 'url', 'default' => ''],
   ],
   'button' => [
       'login_position' => ['type' => 'enum', 'enum' => ['before', 'after', 'hidden'], 'default' => 'before'],
       'register_position' => ['type' => 'enum', 'enum' => ['before', 'after', 'hidden'], 'default' => 'after'],
       'login_text' => ['type' => 'string', 'default' => '使用 LINE 登入', 'max_length' => 50],
       'register_text' => ['type' => 'string', 'default' => '使用 LINE 註冊', 'max_length' => 50],
       'bind_text' => ['type' => 'string', 'default' => '綁定 LINE 帳號', 'max_length' => 50],
       'unbind_text' => ['type' => 'string', 'default' => '解除 LINE 綁定', 'max_length' => 50],
       'style' => ['type' => 'enum', 'enum' => ['official', 'minimal', 'custom'], 'default' => 'official'],
       'custom_class' => ['type' => 'string', 'default' => ''],
   ],
   'email' => [
       'capture_enabled' => ['type' => 'boolean', 'default' => true],
       'required' => ['type' => 'boolean', 'default' => false],
       'source' => ['type' => 'enum', 'enum' => ['line_profile', 'user_input'], 'default' => 'line_profile'],
   ],
   'integrations' => [
       'fluentcart_enabled' => ['type' => 'boolean', 'default' => false],
       'woocommerce_enabled' => ['type' => 'boolean', 'default' => false],
       'other_login_enabled' => ['type' => 'boolean', 'default' => false],
   ],
   'sync' => [
       'on_login' => ['type' => 'boolean', 'default' => false],
       'fields' => ['type' => 'array', 'default' => ['display_name', 'avatar', 'email']],
       'conflict_strategy' => ['type' => 'enum', 'enum' => ['line_priority', 'wordpress_priority', 'manual'], 'default' => 'line_priority'],
   ],
   'liff' => [
       'id' => ['type' => 'string', 'default' => ''],
       'endpoint_url' => ['type' => 'url', 'default' => ''],
   ],
   ```

3. **get_defaults(string $group) 方法**：回傳群組的預設值陣列

4. **validate(string $group, array $data) 方法**：驗證資料並回傳驗證後的資料或 WP_Error
   - enum 類型：檢查值是否在允許清單
   - boolean 類型：轉換為 bool
   - string 類型：使用 sanitize_text_field，檢查 max_length
   - url 類型：使用 esc_url_raw
   - array 類型：確保是陣列

5. **get_sensitive_fields(string $group) 方法**：回傳需要加密的欄位名稱陣列

6. **LEGACY_OPTION_MAP 常數**：定義舊 option key 到新結構的對應關係
   用於向後相容遷移：
   ```php
   private const LEGACY_OPTION_MAP = [
       'button' => [
           'buygo_line_login_button_position' => 'login_position',
           'buygo_line_register_button_position' => 'register_position',
       ],
       // 其他群組的舊 key 對應...
   ];
   ```

7. **get_legacy_map(string $group) 方法**：回傳群組的舊 option key 對應表

Namespace: `BuygoLineNotify\Schemas`
  </action>
  <verify>
1. 檔案存在：`ls includes/schemas/class-settings-schema.php`
2. Namespace 正確：`grep "namespace BuygoLineNotify" includes/schemas/class-settings-schema.php`
3. 所有群組定義：`grep -E "messaging_api|login|button|email|integrations|sync|liff" includes/schemas/class-settings-schema.php | wc -l` 應 >= 7
4. LEGACY_OPTION_MAP 存在：`grep "LEGACY_OPTION_MAP" includes/schemas/class-settings-schema.php`
5. PHP 語法檢查：`php -l includes/schemas/class-settings-schema.php`
  </verify>
  <done>
Settings_Schema 類別完成，包含：
- 7 個設定群組的完整 Schema 定義
- 每個欄位有 type, default, 和驗證規則
- validate() 方法可驗證並清理輸入資料
- get_sensitive_fields() 可識別需加密的欄位
- LEGACY_OPTION_MAP 和 get_legacy_map() 支援向後相容遷移
  </done>
</task>

<task type="auto">
  <name>Task 2: 擴展 SettingsService 支援群組化操作</name>
  <files>includes/services/class-settings-service.php</files>
  <action>
擴展現有的 SettingsService，新增群組化操作方法。保持所有現有方法不變（向後相容）。

新增以下方法：

1. **get_group(string $group): array**
   - 從 `buygo_line_{group}` option 讀取群組設定
   - **向後相容遷移邏輯**：檢查舊 option keys 並遷移到新結構
   - 使用 Settings_Schema::get_defaults($group) 合併預設值
   - 解密敏感欄位
   - 回傳完整的設定陣列

   向後相容遷移實作範例：
   ```php
   public static function get_group(string $group): array {
       $option_key = 'buygo_line_' . $group;
       $stored = get_option($option_key, []);

       // 向後相容：檢查舊 option keys 並遷移
       $legacy_map = Settings_Schema::get_legacy_map($group);
       if (!empty($legacy_map)) {
           foreach ($legacy_map as $old_key => $new_field) {
               // 如果新結構中沒有此欄位，但舊 key 存在
               if (!isset($stored[$new_field])) {
                   $old_value = get_option($old_key, null);
                   if ($old_value !== null) {
                       $stored[$new_field] = $old_value;
                       // 可選：刪除舊 key（或保留供其他外掛使用）
                       // delete_option($old_key);
                   }
               }
           }
           // 如果有遷移的資料，儲存到新結構
           if (!empty($stored)) {
               update_option($option_key, $stored);
           }
       }

       // 合併預設值
       $defaults = Settings_Schema::get_defaults($group);
       $settings = wp_parse_args($stored, $defaults);

       // 解密敏感欄位
       $sensitive = Settings_Schema::get_sensitive_fields($group);
       foreach ($sensitive as $field) {
           if (!empty($settings[$field])) {
               $settings[$field] = self::decrypt($settings[$field]);
           }
       }

       return $settings;
   }
   ```

2. **set_group(string $group, array $data): bool|WP_Error**
   - **先呼叫 Settings_Schema::validate() 驗證資料**
   - 驗證失敗回傳 WP_Error
   - 加密敏感欄位（使用現有 encrypt() 方法）
   - 儲存到 `buygo_line_{group}` option
   - 成功回傳 true

   驗證流程實作範例：
   ```php
   public static function set_group(string $group, array $data): bool|\WP_Error {
       // 步驟 1: 驗證資料
       $validated = Settings_Schema::validate($group, $data);
       if (is_wp_error($validated)) {
           return $validated;  // 驗證失敗，回傳 WP_Error
       }

       // 步驟 2: 加密敏感欄位
       $sensitive = Settings_Schema::get_sensitive_fields($group);
       foreach ($sensitive as $field) {
           if (!empty($validated[$field])) {
               $validated[$field] = self::encrypt($validated[$field]);
           }
       }

       // 步驟 3: 儲存到 option
       $option_key = 'buygo_line_' . $group;
       $result = update_option($option_key, $validated);

       return $result !== false;
   }
   ```

3. **get_all_groups(): array**
   - 回傳所有群組的設定
   - 用於 API 的批次讀取

4. **修改 $encrypted_fields 定義**
   改為從 Schema 動態取得：
   ```php
   private static function get_encrypted_fields_for_group(string $group): array {
       return Settings_Schema::get_sensitive_fields($group);
   }
   ```

5. **新增 use 語句**
   ```php
   use BuygoLineNotify\Schemas\Settings_Schema;
   ```

注意事項：
- 不要修改現有的 get/set/delete 方法（保持向後相容）
- 不要修改現有的 get_* 便捷方法
- 群組化 option key 格式：`buygo_line_{group}`（與現有格式一致）
  </action>
  <verify>
1. 新方法存在：`grep -E "get_group|set_group|get_all_groups" includes/services/class-settings-service.php | wc -l` 應 >= 3
2. Schema 整合：`grep "Settings_Schema" includes/services/class-settings-service.php`
3. 向後相容邏輯：`grep "get_legacy_map\|legacy_map" includes/services/class-settings-service.php`
4. 驗證流程：`grep "Settings_Schema::validate" includes/services/class-settings-service.php`
5. 向後相容：`grep "public static function get\(" includes/services/class-settings-service.php`（原方法保留）
6. PHP 語法檢查：`php -l includes/services/class-settings-service.php`
  </verify>
  <done>
SettingsService 擴展完成：
- get_group() 可讀取群組化設定（含預設值合併和向後相容遷移）
- set_group() 使用 Settings_Schema::validate() 驗證後儲存群組化設定
- get_all_groups() 可批次讀取所有設定
- 敏感欄位自動加密/解密
- 向後相容：舊 option keys 自動遷移到新結構
- 所有原有方法保持不變
  </done>
</task>

<task type="auto">
  <name>Task 3: 註冊 Schema 和 API 類別到 Plugin 載入流程</name>
  <files>includes/class-plugin.php</files>
  <action>
更新 Plugin 類別，確保 Settings_Schema 在 SettingsService 之前載入，並預先註冊 REST API hook。

此 Task 合併了 Schema 載入和 API 路由註冊，避免 01-02 再次修改同一檔案造成衝突。

1. 在 load_dependencies() 或對應的檔案載入方法中新增：
   ```php
   // Schema 類別（必須在 services 之前載入）
   require_once BUYGO_LINE_NOTIFY_PATH . 'includes/schemas/class-settings-schema.php';

   // API 類別（01-02 會建立此檔案）
   if (file_exists(BUYGO_LINE_NOTIFY_PATH . 'includes/api/class-settings-api.php')) {
       require_once BUYGO_LINE_NOTIFY_PATH . 'includes/api/class-settings-api.php';
   }
   ```

   確保載入順序：
   - 先載入 schemas/class-settings-schema.php
   - 再載入 services/class-settings-service.php
   - 最後載入 api/class-settings-api.php（如果存在）

2. 在 register_hooks() 中新增 REST API 註冊 hook：
   ```php
   add_action('rest_api_init', [$this, 'register_rest_routes']);
   ```

3. 新增 register_rest_routes() 方法：
   ```php
   /**
    * 註冊 REST API 路由
    */
   public function register_rest_routes(): void {
       // Settings API（01-02 會建立此類別）
       if (class_exists('\\BuygoLineNotify\\API\\Settings_API')) {
           $settings_api = new \BuygoLineNotify\API\Settings_API();
           $settings_api->register_routes();
       }
   }
   ```

4. 如果有 index.php 需要建立，在 includes/schemas/ 目錄建立：
   ```php
   <?php
   // Silence is golden.
   ```

注意：
- 使用 file_exists() 和 class_exists() 檢查，讓 01-01 可以獨立執行
- 01-02 只需建立 Settings_API 類別，不需再修改 class-plugin.php
  </action>
  <verify>
1. Schema 載入：`grep "settings-schema" includes/class-plugin.php`
2. API 載入（條件式）：`grep "settings-api" includes/class-plugin.php`
3. REST hook 註冊：`grep "rest_api_init" includes/class-plugin.php`
4. register_rest_routes 方法：`grep "register_rest_routes" includes/class-plugin.php`
5. 目錄索引存在：`ls includes/schemas/index.php`
6. PHP 語法檢查：`php -l includes/class-plugin.php`
7. 類別可實例化測試：
   ```bash
   php -r "
   require_once 'includes/schemas/class-settings-schema.php';
   \$schema = new \BuygoLineNotify\Schemas\Settings_Schema();
   echo 'Settings_Schema instantiated successfully' . PHP_EOL;
   "
   ```
  </verify>
  <done>
Plugin 載入流程更新：
- Settings_Schema 類別在 SettingsService 之前載入
- REST API hook 已註冊（rest_api_init）
- register_rest_routes() 方法已建立，使用條件式載入 Settings_API
- 01-02 只需建立 Settings_API 類別檔案，無需再修改 class-plugin.php
- Settings_Schema 類別可正常實例化
  </done>
</task>

</tasks>

<verification>
整體驗證步驟：

1. **檔案結構檢查**
   ```bash
   ls -la includes/schemas/
   ls -la includes/services/class-settings-service.php
   ```

2. **PHP 語法檢查**
   ```bash
   php -l includes/schemas/class-settings-schema.php
   php -l includes/services/class-settings-service.php
   php -l includes/class-plugin.php
   ```

3. **類別可用性測試**
   ```bash
   php -r "
   require_once 'includes/schemas/class-settings-schema.php';
   use BuygoLineNotify\Schemas\Settings_Schema;

   // 測試 get_schema
   \$schema = Settings_Schema::get_schema();
   echo 'Groups: ' . implode(', ', array_keys(\$schema)) . PHP_EOL;

   // 測試 get_defaults
   \$defaults = Settings_Schema::get_defaults('button');
   echo 'button.login_position default: ' . \$defaults['login_position'] . PHP_EOL;

   // 測試 get_legacy_map
   \$legacy = Settings_Schema::get_legacy_map('button');
   echo 'Legacy map count: ' . count(\$legacy) . PHP_EOL;

   echo 'All tests passed!' . PHP_EOL;
   "
   ```

4. **功能驗證（WordPress CLI 或測試腳本）**
   建立測試腳本驗證：
   - Settings_Schema::get_schema() 回傳正確結構
   - Settings_Schema::validate() 正確驗證資料
   - Settings_Schema::get_legacy_map() 回傳遷移對應表
   - SettingsService::get_group() 回傳含預設值的設定（含向後相容遷移）
   - SettingsService::set_group() 先驗證後儲存設定
</verification>

<success_criteria>
Plan 01-01 完成條件：

1. [ ] Settings_Schema 類別存在於 includes/schemas/class-settings-schema.php
2. [ ] Schema 定義包含所有 7 個設定群組（messaging_api, login, button, email, integrations, sync, liff）
3. [ ] 每個設定欄位有 type, default 定義
4. [ ] validate() 方法可正確驗證並清理輸入
5. [ ] LEGACY_OPTION_MAP 定義舊 option key 到新結構的對應
6. [ ] SettingsService 新增 get_group/set_group/get_all_groups 方法
7. [ ] get_group() 包含向後相容遷移邏輯
8. [ ] set_group() 先呼叫 validate() 再儲存
9. [ ] 敏感欄位自動加密/解密
10. [ ] 向後相容：原有 get/set 方法不受影響
11. [ ] class-plugin.php 包含 REST API hook 註冊（供 01-02 使用）
12. [ ] Settings_Schema 類別可正常實例化
13. [ ] 所有 PHP 檔案語法正確
</success_criteria>

<output>
完成後建立 `.planning/phases/01-後端設定架構/01-01-SUMMARY.md`
</output>
